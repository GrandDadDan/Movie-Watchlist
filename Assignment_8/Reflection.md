# Reflection

One of the biggest challenges I faced during this part of the project was figuring out the right level of granularity for the states and actions in my diagrams. At first, I tried to capture every tiny change a user or the system could trigger—like showing a popup or updating a UI component. But the diagrams quickly became overwhelming and hard to read. I had to step back and ask myself: "Is this action meaningful in terms of how the system behaves or progresses?" I ended up simplifying a lot of transitions and only kept what contributed to the overall logic or decision-making in the system. It was a tough balance—too much detail made the diagram messy, but too little made it vague and less useful.

Aligning the diagrams with my Agile user stories was another challenge. User stories focus on outcomes and value ("As a user, I want to…"), while diagrams break things down into technical or visual steps. It wasn’t always easy to map a high-level user story to a diagram with concrete states or actions. I had to go back and look at the acceptance criteria for each story to decide what part of the system’s flow it actually covered. That helped me stay focused and avoid including steps that didn’t add value or weren't directly tied to the story's goals.

A key takeaway for me was understanding the difference between state diagrams and activity diagrams. At first, I thought they were similar, but working on both helped me see their unique purposes. State diagrams helped me model how objects like a user account or a movie transition between different conditions (e.g., "Active" to "Locked" or "Watched" to "Removed"). They’re great for showing how an object behaves over time. On the other hand, activity diagrams helped me visualize step-by-step workflows, especially from the user’s perspective—like registering, logging in, or checking streaming availability. Activity diagrams are more about process flow, while state diagrams are about system response to events.

Overall, doing both types of diagrams gave me a much clearer understanding of how my system works behind the scenes. It also forced me to think not just like a developer, but like a designer and even a product manager—trying to communicate clearly what’s happening at each point in the system. It was challenging, but really worth it.
